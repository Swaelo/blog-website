<!DOCTYPE html>
<html>
	<script src="HTMLInclude.js"></script>
	<head>
		<link rel="icon" href="../favi.ico" type="image/x-icon"/>
		<link rel="stylesheet" href="../style.css">
		<title>swaelo.com</title>
	</head>
	<body>
		<div class="middlecolumn">
			<div w3-include-html="../navigation.html"></div>
			<script>includeHTML();</script>

			<div class="cardholder">
				<div class="card">
					<h2>Been fiddling with the dungeon generation algorithm a bit</h2>
					<h5>24-May-2020</h5>
					<p>I've spent some time experimenting with the dungeon generation because I don't really like having all the dungeon rooms connected together by big long empty corridors.</br>
						I've made an alternate version of the generation algorithm which places all dungeon rooms adjacent to one another, so the player should be able to travel directly from one room to the next, without having to waste time travelling through corridors.</br>
						I think this works much better, I'm quite happy with how the layouts appear using this new method that I've created.</br>
						Heres a quick peek at how it looks when trying it out.</br></br>
						<img src="files/CompactedGenExample.gif" alt="Compacted Dungeon Generation GIF" style="width:50%;height:50%;"></br></p>
				</div>

				<div class="card">
					<h2>Starting work on a new original project, not another clone this time!</h2>
					<h5>15-May-2020</h5>
					<p>Over the last few months I've completed work on a few different clones of various classics from the arcade era.</br>
						My main reason for wanting to make these was to help build my familiarity with building 2D games in the Unity engine, as all of my previous experience over the years had been with creating 3d projects.</br>
						I feel quite comfortable now working in Unity with 2D, so I've decided to move on from making any more clones and start work on my own original game.</br>
						Out of the clones I've made, Robotron has by far been my favorite to work on and my favorite to play.</br>
						So what I'm wanting to do is take that core gameplay experience, and expand it into a full on rogue-like game.</br></br>

						During the Robotron development, I had an absolute blast programming the AI for all the different enemy types as they each have their own unique set of behaviours.</br>
						I want to create many more different types of enemies like these, some of them similar to whats already in Robotron and others being much different and even more complicated.</br>
						I'll want to spend some time studying a lot more about AI related topics before I really get deep into working on that part of the game though.</br>
						I've already been messing around with a bunch of different pathfinding algorithms lately, I still want to try out a few more of those and get them implemented into my pathfinding project first though.</br>
						A* seems like it would be great to use for most occasions, but it does bother me a little how some of the obviously non-optimal pathways sometimes appear.</br>
						Jump Point Search is something I've been reading a lot about lately, and it looks very promising but actually getting that implemented seems a little daunting at the moment, I think I'll have to bunker down and spend a good day or two with that one before I get the hand of it.</br>
						When I find a pathfinding algorithm that I'm happy with, I'll be wanting to then go and implement a whole behaviour tree system for all the enemies to use which will make coding all their advanced behaviours much easier.</br></br>

						Once all the enemy AI stuff has been sorted out, the other big task that this type of game is going to require is some form of procedural level generation.</br>
						This is something I got started on this week, and I already have a little random dungeon layout generation sample project that I can show off.</br>
						You can try out the random dungeon generator <a href="projects/dungeon-generation/" target="_blank">here</a>, this is just the first type of procedural generation I was able to implement.</br>
						Can also just watch this gif of me messing around with it to show you what kinda layouts it can currently generate.</br>
						<img src="files/SpacedGenExample.gif" alt="Random Dungeon Generation GIF" style="width:50%;height:50%;"></br>
						It doesnt seem that bad, but I'll probably be trying out some other forms of layout generation so I can see what works best for me before I make the final decision on what type of generation I will be using for the game.</br>
						Stay tuned for more updates coming soon, first thing I want to try next is binary space partitioning for dungeon layout - then I might see if I can get some first super basic gameplay demo up and running.</p>
				</div>

				<div class="card">
					<h2>Theta* added</h2>
					<h5>10-May-2020</h5>
					<p>I've added support for the <a href="https://en.wikipedia.org/wiki/Theta*" target="_blank">Theta* Algorithm</a>, this was fairly quick and easy to add in as its very similar to A*.</br>
						Here's a few short gifs showing off what each of the pathfinding algorithms look like while they do their thing.</p>
						<h4>A* Example</h4> <img src="files/AStar.gif" alt="A* GIF" style="width:50%;height:50%;"></br>
						<h4>Theta* Example</h4> <img src="files/ThetaStar.gif" alt="Theta* GIF" style="width:50%;height:50%;"></br>
						<h4>Dijkstra's Example</h4> <img src="files/Dijkstras.gif" alt="Dijkstras GIF" style="width:50%;height:50%;">
						<p>After running some tests and checking out how these 3 algorithms compare against one another, I've found that A* is considerably faster at finding a pathway to the target node.</br>
							However its not perfect, although A* can find a path in a fraction of the time it takes for the other two, the pathways created by A* are sometimes less than ideal, as seen in this example.</br></br>
							<img src="files/NonOptimalPathExample.png" alt="A* Non Optimal Path Example" style="width:50%;height:50%;"></br></br>
							This isnt the worst thing in the world though, because of damn faster this is at finding some halfway decent pathway I think I may be able to use this to find a path, then perform some processing on that pathway to clean it up a bit, we may end up with something much better.</p>
				</div>

				<div class="card">
					<h2>Pathfinding algorithm testing project started</h2>
					<h5>09-May-2020</h5>
					<p>I've started work on a new little project in which I'm going to implement a bunch of different pathfinding algorithms so they can easily be tested and compared against one another.</br>
						The first version is live now, and currently supports <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" target="_blank">Dijkstra's Algorithm</a> and the <a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank">A* search algorithm</a>.</br>
						You can try it out <a href="projects/pathfinding/" target="_blank">here</a>.</p>
				</div>

				<div class="card">
					<h2>Robotron & Asteroid clones completed</h2>
					<h5>02-May-2020</h2>
					<p>It's been a good couple months since my last blog post, we moved into a new house and unfortunately NBN wasnt hooked up at the new place yet and we had to wait a good while for them to hook it up for us.</br>
						As I host the website and everything else I do completely on my own its meant this websites also been offline for the whole time.  But happily now were back online so I can get back to work now :)</br>
						Now while I was without internet, I was able to finish off the Robotron clone and I was also able to start and finish an Asteroids clone too!</br>
						You can play Robotron <a href="games/robotron/" target="_blank">here</a>, or Asteroids <a href="games/asteroids/" target="_blank">here</a>.</p>
				</div>

				<div class="card">
					<h2>Robotron Art Assets Complete</h2>
					<h5>29-Feb-2020</h5>
					<p>Over the last few days I've painstakingly recreated all the sprites that are used in Robotron, this took much longer than I expected but I've learned a lot.</br>
						Previously with the Pong and Breakout projects, I actually created those games in 3D and just used an orthographic camera to make them appear as they were 2d games.</br></br></p>
						<img src="http://swaelo.com/files/PongBreakoutFake2D.png" alt="Pong/Breakout Fake 2D" style="width:50%;height:50%;">
					<p>I havn't got that much experience making real 2D games in Unity so I forced myself to stop cheating with fake 2D and actually make this game in 2D.</br>
						I learned how to space out all my sprite sheets correctly, then how to import those into Unity, slice them up with the Sprite Editor then use those to create animations.</br>
						The Sprite Animator and Animation Controller systems are very much the same in Unity when you're working with 3D projects, so this was extremely quick for me to get used to.</br>
						Even still, the process of recreating every sprite from Robotron by hand, spacing out sprite sheets, importing into Unity and setting up all the animations with them was a very tiresom process.</br>
						Working on this on and off while I was able to keep my sanity intact only took me a few days to get everything completed.</br>
						I'm yet to write a single line of code for this project, but all assets are now ready so I will be able to get started on this now no problem.</p>
						<img src="files/RobotronAssets.gif" alt="Robotron Art Assets GIF" style="width:50%;height:50%;">
				</div>

				<div class="card">
					<h2>Pong Update 2</h2>
					<h5>23-Feb-2020</h5>
					<p>Today I've made the 2nd update to my Pong clone, which just includes a few small changes.</br>
						Again I've redone the ball physics based on progress that I made in the Breakout clone.</br>
						Just like in the Breakout clone, I've changed all the collision detection to use OnCollisionEnter instead of OnTriggerEnter so I can get more information about the collision that has taken place.</br>
						This allows me to get the normal of any surface the ball collides with, and use that with the Vector3.Reflect function to get the new direction of the ball after it bounces off that surface.</br>
						A 3-2-1 countdown has been added before the start of each round.</br>
						Some basic sound effects have been added</br></br>
						Next I'll be working on updating the project so it uses the LightWeight Render Pipeline, which will give me access to Shader Graph.</br>
						Through the use of Shader Graph I'll be able to start making custom shaders and adding all sorts of special visual effects to the game.</br>
				</div>

				<div class="card">
					<h2>Planning Robotron</h2>
					<h5>19-Feb-2020</h5>
					<p>Next game I'm going to make is going to be another arcade classic, <a href="https://en.wikipedia.org/wiki/Robotron:_2084" target="_blank">Robotron 2084</a>, released by Williams Electronics in 1982.</br>
						Some other games I considered doing next were Asteroids and Galaga, however Robotron is a favorite of mine and I thought it would be much more fun to work on this next.</br>
						The gameplay for Robotron is quite simple, its a top down twinstick shooter which takes place entirely on one screen.</br>
						The gameplay loop is structured in an endless set of waves the player must clear through, when all enemies on the screen are defeated it automatically progresses to the next round.</br>
						This continues forever allowing the player to collect more and more points, until eventually they run out of lives and reach a gameover.</br>
						Points are earned by defeating enemies, but also there can be other humans in the level which have been abducted by the robots which award points to the player if they can be rescued.</br>
						That's about all there is to this game, the complexity of gameplay and reason I love this game so much is the wide range of enemies that can appear which all have different behaviours which can cause all sorts of situations.</br></p>

						<h6>The Enemies</h6>
						<p><b>Electrodes</b> are the most basic enemy the player will encounter in the game.</br>
						These enemies do not move or attack the player in anyway, however if the player comes in contact with an Electrode they will be immediately killed as the Electrode will explode.</br>
						Electrodes can easily be shot and destroyed by the player, which may immediately appear to be the best solution.</br>
						However, they will also explode when coming into contact with enemies so it may be more advantageous to avoid destroying them so enemies can be lured in for an easy kill.</br></br>

						<b>Grunts</b> are another common enemy which aim to hunt down the player by continuously following the shortest path available to reach them.</br>
						These enemies are very slow moving and their movement is very predictable, so they are easy to avoid if the player is paying attention.</br>
						However they must be taken care of quickly, as their speed continues to increase the longer they remain alive eventually reaching a frenzied charge which is very difficult to escape from.</br>
						The Grunts are quite easy to take care of on their own, but over time they start to appear in larger and larger groups.</br>
						Some waves even consist of only a large number of Grunts and nothing else, surviving these Grunt waves can be one of the most difficult challenges faced by the player.</br></br>

						<b>Hulks</b>, these giant enemies cannot be killed by the player, however they are very slow and stupid so they are easily to avoid.</br>
						They constantly try and move towards some random location offset from the player, however this includes a high amount of randomization so they can sometimes be very difficult to predict.</br>
						It can be useful sometimes to leave the Hulks alive if possible, as they can block projectiles from being able to reach the player.</br>
						Due to their large size and their seeking behaviour keeping them somewhat near the player this can be a very helpful strategy to employ.</br>
						Hulks will crush any humans they come into contact with, which can be unfortunate if they are led to the wrong area.</br>
						Although the Hulks cannot be killed by the player, their shots will push them back a small amount which is very useful to help keep them away from any humans you are trying to rescue.</br></br>

						<b>Enforcers</b> are the first enemy seen that can actually fire projectiles back at the player, making them extremely dangerous.</br>
						They're also the first flying enemy, which means the player wont be able to take advantage of Electrodes to help kill these.</br>
						The Enforcers movement pattern is much more complex than the previous Grunt or Hulk enemies we looked at earlier.</br>
						The Enforcers seek towards the the player with a random offset, and a randomized velocity that is inversely proportional to the distance to the player.</br>
						This randomized velocity is frequently updated, causing them to move in a smooth but sometimes erratic fashion.</br>
						The Enforcers fire shots at the player, these shots have a velocity directly proportional to their distance from the player, meaning the further the Enforcer is from the player the faster the projectile will travel.</br>
						Most of these shots will be aimed towards the player, with a small amount of spread around the players location.</br>
						A small percentage of these shots however, will be aimed at directly where the player is predicted to be when the shot reaches them.</br>
						Their shots also have a random acceleration value calculated upon firing, which is then added to the shots velocity each frame.</br>
						This causes the infamous "curve balls" which can be extremely deadly to the player.</br>
						Lastly, if the Enforcers shots hit any of the screen boundaries they will then slide along that wall until they settle into one of the corners.</br></br>

						<b>Brains</b> are an interesting enemy, they seek out any remaining humans which they brainwash and turn into Progs.</br>
						Progs are very similar to the Grunts, they simply seek the player in order to destroy them.</br>
						Brains will also fire cruise missiles which have a very unpredictable movement pattern, combined with their very small hitbox making them very hard to destroy.</br></br>

						<b>Tanks</b> were originally one of the final enemies that were added to the game, which specialize in firing projectiles at the player to kill them.</br>
						Half of the Tanks shots will fire directly at the player, with the other aimed in such a way to hit the player after first bouncing off one of the walls.</br>
						These rebound shots can sometimes catch the player off guard if they have grown acustomed to the Enforcers shots which slide down the walls instead of bouncing off.</br></br>

						<b>Spheroids</b> and <b>Quarks</b> are the two final enemies in the game, which are both enemy generators not having any attacks of their own.</br>
						The Spheroids will spawn Enforcers, and the Quarks will spawn Tanks.</br>
						These enemy spawners will each only spawn a maximum of 6 enemies if they are left alive long enough, after which they wont spawn any more.</br>

				</div>

				<div class="card">
					<h2>Breakout v1</h2>
					<h5>17-Feb-2020</h5>
					<p>Over the last couple days I've been hard at work making my clone of Breakout and its finally ready to be played.</br>
						I honestly had a little bit tougher of a time implementing this game than I had initially expected.</br>
						Troubling me for a while on this one was getting the physics between the ball and the blocks you destroy to act correctly.</br>
						Mostly what I've spent my time doing in the last few years is developing 3d games, so these kind of 2d physics was a bit different to the stuff I'm used to.</br>
						In the previous Pong project all I did for the ball physics was reverse its current X or Y velocity whenever it collided with one of the paddles or walls, but colliding with the boxes in this game was a bit trickier than that.</br>
						Depending on which side of the box the ball collided with, the physics reaction of the ball needed to be totally different.</br>
						I avoided looking up any tutorials or other works for referencing when figuring out how to solve this as I wanted to see if I could solve it on my own, and I was eventually able to after a few failed attempts.</br></p>

						<h6>What I ended up doing</h6>
						<p>Previously I was using OnTriggerEnter to detect whenever the ball collided with something, I changed a few things around and now started using OnCollisionEnter instead, as that provides you with more useful information.</br>
						I also changed back to storing the balls current direction and movement speed values and using those to interpolate the balls position every frame, instead of applying forces to the rigidbody component.</br>
						Now whenever the ball collided with something, I use the information provided by the OnCollisionEnter function to get the normal of whatever surface the ball has hit.</br>
						Then I pass in the balls current direction, aswell as that surface normal into the Vector3.Reflect function to find the balls new heading after bouncing off that surface.</br></p>

						<h6>Closing thoughts</h6>
						<p>Everything else was fairly simple to implement and didn't really cause me any headaches.</br>
						I did end up creating a 3d model for the blocks in blender and unwrapping that myself so I could make custom textures, to give them the strong border with a lighter color on the inside look.</br>
						I'm only left with 1 bug in the game currently that I'm aware of, which gets the ball stuck inside the paddle if you move the paddle sideways on top of the ball very quickly when they on the same elevation.</br>
						Fixing this problem, aswell as some other things like balancing the sound levels, adding music and a highscores table will be jobs for the next version of the game that I will make in the future.</br></p>
				</div>

				<div class="card">
					<h2>Planning Breakout</h2>
					<h5>14-Feb-2020</h5>
					<p>The second game I've decided to add here to my portfolio website is another Atari classic, <a href="https://en.wikipedia.org/wiki/Breakout_(video_game)" target="_blank">Breakout</a>.</br>
					Breakout was the natural evolution after Pong, and was originally released in 1976.</br>
					Before I get started creating this game, I thought it best to study the mechanics of the original and write up a little design document explaining exactly how everything is going to work.</br></br>
					Firstly, here's a little mockup image I quickly threw together in mspaint to get a rough idea how the game might look once its done.</br></br></p>
					<img src="files/BreakoutConcept.png" alt="Breakout Concept" style="width:50%;height:50%;">

					<h6>Block Mechanics</h6>
					<p>There is going to be 5 rows of blocks that the player needs to destroy, with each row being a different color from one another, and each different colored block producing different effects once they have been destroyerd.</br>
					Blocks will play a short sound effect when they are destroyed, with each different color having their own unique sound effect that will be played.</br>
					Starting from the bottom, the blue blocks will produce a low pitched sound, and then moving up to the top, each row will produce a higher pitched sound than the previous with the highest row of red blocks producing the highest pitch sound when they are destroyed.</br>
					Points will be awarded to the player when blocks are destroyed, with each color having its own unique point value assigned to it.</br>
					Blue blocks will award only 1 point, greens give 3 points, yellow blocks give 5 points, orange blocks give 7 points and finally red blocks give the player a whopping 10 points.</br>
					The orange and red blocks will have a special event coded into them, which triggers the first time any one of those orange or red blocks is destroyed during any single match.</br>
					This event causes the speed of the ball to immediatly double, and remain at this speed until the ball is lost.  Once it resets and a new round begins the speed returns back to normal, until another orange or red block is destroyed.</br></p>

					<h6>UI Elements</h6>
					<p>There are minimal UI elements which only include a couple of numbers that are displayed to the user during gameplay.</br>
					The first is the players score which is displayed in the top-right corner of the screen.</br>
					In the opposite corner, over in the top-left is another number which lets the user know how many balls they have remaining.</br>
					These are the only UI elements that are displayed during gameplay, once the player reaches a gameover state there will also be a small menu displayed to the user.</br>
					This menu will simply present the player with their final score, and a button they can click to start over and play a new game from the beginning.</br></p>

					<h6>End States</h6>
					<p>If at any point the player fails to hit the ball back with their paddle, and the ball falls below the bottom of the screen then the round is over and that ball is lost.</br>
					Whenever this happens 1 point will be taken from the players ball counter, after which the ball will be reset and gameplay begin again.</br>
					However, if the player loses their final ball then its a game-over, the player will be presented with their final score and given the option to start a new game.</br>
					I think its worth mentioning that some kind of global highscores board is something that I would love to add into the game, but I'll be leaving that for another time.</br></br></p>

					<p>When thinking about what I want to happen if the player succeeds in clearing all the blocks from the level without reaching gameover, I would like the game to continue on to some other different and more difficult levels.</br>
					However, I can see this starting to fall on the side of feature-creep, so atleast for the time being we will go with a more simple solution.</br>
					If the player manages to clear the board of all blocks without reaching a game-over, then all the blocks will simply be placed back onto the board again allowing the player to keep on destroying and collecting more points until they run out of lives.</br></p>

					<h6>Code Reuse</h6>
					<p>To get things started I plan on reusing some of the code from my Pong project.</br>
					First will be the code for controlling the movement and physics of the ball.</br>
					The ball movement in Pong and Breakout is almost exactly the same, so I should be able to save some time by reusing the code I've already written for Pong.</br>
					Just to help get things up and running more quickly I'll also be bringing over the code from Pong which allows the player to move the paddle around with the keyboard.</br>
					However, I will be expanding upon this code at a later point in order to add some additional functionality once most other things have been setup.</br>
					I will be making it so the player will be able to control the paddle with the mouse cursor, this will allow for a far greater level of control and precision of movement.</br></p>

					<h6>Final Thoughts</h6>
					<p>That just about wraps up everything I can think of, every gameplay mechanic and feature of the program has been outlined and defined clearly enough.</br>
					The whole game should now be a lot easier for me to implement as I have a very clear understanding of how everything is going to work and what needs to be done.</br>
					All thats left to do now is follow my own instructions and get the game made, so now off I go to begin my work.</br></p>
				</div>

				<div class="card">
					<h2>Pong Update 1</h2>
					<h5>12-Feb-2020</h5>
					<p>Today I've made a some big updates to the ball movement in my pong game.</br>
					Previously, I had a couple of float values (XDirection and YDirection) for tracking the balls trajectory in each direction.</br>
					Whenever the ball collided with something on the table, I would adjust these values accordingly, and then at the end of each game update I would offset the balls position with these values to move it around the table.</p>
					<script src="https://gist.github.com/Swaelo/7d51dfb51a09b5bcabc8feb2632e9aa5.js"></script>

					<p>I have now added a rigidbody component to the ball which is now used to handle the balls movement.</br>
					To make changes to the balls direction and speed forces are now applied to this rigidbody component.</br>
					I have also made some changes in how the ball reacts when colliding with the paddles.</br>
					If the ball collides with a paddle and that paddle is moving, force is applied to the ball based on the movement direction of the paddle to change the balls vertical velocity.</br>
					If the paddle is not moving at all, a small random value is either added or taken away from the balls vertical velocity to add some randomness to the game.</br></p>
					<script src="https://gist.github.com/Swaelo/88262209e3f56bc609c756d187bf44fe.js"></script>

					<p>Firstly, the small change of making small random adjustments to the balls vertical velocity when colliding with a stationary paddle prevents the game from reaching a kind of dead state if the ball is moving in a straight line and neither player wants to move their paddle.</br>
					Secondly, changing the vertical velocity of the ball based on the movement of the paddles adds a lot more depth to the game, allowing players to add spin to the ball, making it harder for their opponents to guess where the ball is going to go.</br>
					In my next update, I will be making some audio-visual updates to the game.</br>
					This will include some sound effects, particle effects, shader effects and possibly some music will be added to the game, so stay tuned.</br></p>
				</div>
			</div>
		</div>
	</body>
</html>
